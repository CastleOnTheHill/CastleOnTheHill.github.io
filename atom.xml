<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rhino&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-20T12:35:14.843Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rhino Hu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vmware虚拟机配置代理上网</title>
    <link href="http://yoursite.com/2020/12/20/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2020/12/20/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/</id>
    <published>2020-12-20T11:31:03.000Z</published>
    <updated>2020-12-20T12:35:14.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主机设置"><a href="#主机设置" class="headerlink" title="主机设置"></a>主机设置</h2><p>主机的小飞机需要勾选，选项设置-&gt;本地代理-&gt;允许来自局域网的连接。</p><p><img src="/2020/12/20/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE.png" alt="设置图片"></p><h2 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h2><p>看到一些博客说，虚拟机一定要设置为桥接模式，实际上是任何模式都行，只要虚拟机能够ping通主机的ip地址。就能使用主机的代理。</p><p>在bashrc下设置终端程序走代理, 填主机的ip和小飞机监听的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;address:port</span><br><span class="line">export https_proxy&#x3D;https:&#x2F;&#x2F;address:port</span><br></pre></td></tr></table></figure><p>设置应用程序走代理：<br><img src="/2020/12/20/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/ubuntu%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86.png" alt="ubuntu设置全局代理"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主机设置&quot;&gt;&lt;a href=&quot;#主机设置&quot; class=&quot;headerlink&quot; title=&quot;主机设置&quot;&gt;&lt;/a&gt;主机设置&lt;/h2&gt;&lt;p&gt;主机的小飞机需要勾选，选项设置-&amp;gt;本地代理-&amp;gt;允许来自局域网的连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/202</summary>
      
    
    
    
    
    <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL加载骨骼动画</title>
    <link href="http://yoursite.com/2019/07/03/OpenGL%E5%8A%A0%E8%BD%BD%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/03/OpenGL%E5%8A%A0%E8%BD%BD%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/</id>
    <published>2019-07-03T02:54:06.000Z</published>
    <updated>2020-12-20T12:16:49.801Z</updated>
    
    <content type="html"><![CDATA[<p>一般的模型的加载在<a href="https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/">LeanOpenGL</a>里已经讲解得比较清楚了，本博文是介绍如何在<a href="https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/">LeanOpenGL</a>示例<code>Mesh.h</code>，和<code>Model.h</code>基础之上扩展，使其支持骨骼动画的播放。</p><h2 id="骨骼动画的原理"><a href="#骨骼动画的原理" class="headerlink" title="骨骼动画的原理"></a>骨骼动画的原理</h2><p><img src="/2019/07/03/OpenGL%E5%8A%A0%E8%BD%BD%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/assimp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Assimp数据结构"></p><p>带有骨骼动画的模型除了有skin（即一系列的网格），还有骨骼<code>aiBone</code>和动画<code>aiAnimation</code>。骨骼没有大小和位置，只有一个名字和初始旋转矩阵（决定了骨骼的初始姿态），除此之外，每一个骨骼还存储了它所影响的顶点的ID以及影响的权重；动画<code>aiAnimation</code>存储了一系列的关键帧和当前动画的持续时间。关键帧存储的是从初始姿态到当前姿态，所有骨骼要经过的旋转平移和缩放。</p><p>在骨骼动画播放的时候，首先根据当前时间找到动画的前一个关键帧和后一个关键帧，然后根据到这两个关键帧的时间距离进行线性插值，得到当前关键帧。再将当前关键帧的旋转平移和缩放应用到所有相关的骨骼上，从而改变当前的骨骼姿态。</p><p><img src="/2019/07/03/OpenGL%E5%8A%A0%E8%BD%BD%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E6%92%AD%E6%94%BE.png" alt="骨骼动画播放"></p><p>最后在着色器中，将骨骼当前的姿态，按照权重作用到受其影响的顶点上，从而改变顶点的位置。</p><h2 id="骨骼相关数据的加载"><a href="#骨骼相关数据的加载" class="headerlink" title="骨骼相关数据的加载"></a>骨骼相关数据的加载</h2><h3 id="扩展Mesh中的顶点结构体："><a href="#扩展Mesh中的顶点结构体：" class="headerlink" title="扩展Mesh中的顶点结构体："></a>扩展<code>Mesh</code>中的顶点结构体：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BONE_INFO_NUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line"><span class="comment">// position</span></span><br><span class="line">glm::vec3 Position;</span><br><span class="line"><span class="comment">// normal</span></span><br><span class="line">glm::vec3 Normal;</span><br><span class="line">    <span class="comment">// 这里的注释是因为项目中使用的都是多边形的模型，并没有纹理贴图，所以去掉了</span></span><br><span class="line"><span class="comment">//// texCoords</span></span><br><span class="line"><span class="comment">//glm::vec2 TexCoords;</span></span><br><span class="line"><span class="comment">//// tangent</span></span><br><span class="line"><span class="comment">//glm::vec3 Tangent;</span></span><br><span class="line"><span class="comment">//// bitangent</span></span><br><span class="line"><span class="comment">//glm::vec3 Bitangent;</span></span><br><span class="line">glm::ivec4 boneID; <span class="comment">//影响骨骼ID</span></span><br><span class="line"></span><br><span class="line">glm::vec4 boneWeight; <span class="comment">// 对应权重</span></span><br><span class="line"></span><br><span class="line">Vertex() &#123;</span><br><span class="line">Position = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">Normal = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">boneID = glm::ivec4(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">boneWeight = glm::vec4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoneData</span><span class="params">(uint BoneID, <span class="keyword">float</span> Weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BONE_INFO_NUM; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Weight &gt; boneWeight[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = BONE_INFO_NUM - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">boneWeight[j] = boneWeight[j - <span class="number">1</span>];</span><br><span class="line">boneID[j] = boneID[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">boneWeight[i] = Weight;</span><br><span class="line">boneID[i] = BoneID;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalizeBoneWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> totalWeight = boneWeight.x + boneWeight.y + boneWeight.z + boneWeight.w;</span><br><span class="line">boneWeight.x = boneWeight.x / totalWeight;</span><br><span class="line">boneWeight.y = boneWeight.y / totalWeight;</span><br><span class="line">boneWeight.z = boneWeight.z / totalWeight;</span><br><span class="line">boneWeight.w = boneWeight.w / totalWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>顶点记录了影响它的骨骼的ID<code>boneID</code>，和对应的权重<code>boneWeight</code>，影响顶点的骨骼数量是没有上限的，在这里我们<strong>只取影响最大的4个骨骼</strong>。这里要注意的是，只取最大的四个，最后他们的权重和并不为1，导致在播放骨骼动画的时候，模型会变形，<strong>所以在所有骨骼都处理完毕之后，要对每一个顶点执行<code>normalizeBoneWeight</code>函数，使它们的权重值和为1</strong>。</p><h3 id="加载骨骼数据并归一化"><a href="#加载骨骼数据并归一化" class="headerlink" title="加载骨骼数据并归一化"></a>加载骨骼数据并归一化</h3><p>在加载完<code>Mesh</code>的其他数据的时候，遍历<code>Mesh</code>中的所有骨骼，将骨骼的ID和权重添加到对应的顶点的属性中，这里参照<code>ogldev</code>教程（参考3）的做法，所有<code>Mesh</code>的骨骼是存在一起的，这样方便最后一次性将所有骨骼的姿态传入着色器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载骨骼权重信息到顶点，并将骨骼加入allBones和boneMap</span></span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; mesh-&gt;mNumBones; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> BoneIndex = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">BoneName</span><span class="params">(mesh-&gt;mBones[i]-&gt;mName.data)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (boneMap.find(BoneName) == boneMap.end()) &#123;</span><br><span class="line"><span class="comment">// Allocate an index for a new bone</span></span><br><span class="line">BoneIndex = numBones;</span><br><span class="line">numBones++;</span><br><span class="line">Bone tmpBone;</span><br><span class="line">tmpBone.boneOffset = mesh-&gt;mBones[i]-&gt;mOffsetMatrix;</span><br><span class="line">tmpBone.name = BoneName;</span><br><span class="line"><span class="comment">// 加入map</span></span><br><span class="line">boneMap[BoneName] = BoneIndex;</span><br><span class="line"><span class="comment">// 加入allBones</span></span><br><span class="line">allBones.push_back(tmpBone);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">BoneIndex = boneMap[BoneName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; mesh-&gt;mBones[i]-&gt;mNumWeights; j++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexID = mesh-&gt;mBones[i]-&gt;mWeights[j].mVertexId;</span><br><span class="line"><span class="keyword">float</span> weight = mesh-&gt;mBones[i]-&gt;mWeights[j].mWeight;</span><br><span class="line"><span class="comment">// 给vertices添加影响骨骼信息</span></span><br><span class="line">vertices[vertexID].AddBoneData(BoneIndex, weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有的骨骼都加上影响权重之后</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; vertex : vertices) &#123;</span><br><span class="line">vertex.normalizeBoneWeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="骨骼动画的渲染"><a href="#骨骼动画的渲染" class="headerlink" title="骨骼动画的渲染"></a>骨骼动画的渲染</h2><h3 id="计算当前帧"><a href="#计算当前帧" class="headerlink" title="计算当前帧"></a>计算当前帧</h3><p><em>以下直接直接复用了<code>ogldev</code>教程的源码</em></p><p>这里设置的动画是循环播放的，所以将当前时间以模型持续时间取模，计算出动画的时间位置。</p><p>骨骼是一个树的结构，骨骼树的信息存储在以<code>Scene-&gt;mRootNode</code>为根节点的树中，如果当前<code>node</code>的<code>mName</code>不为空，那么它就代表一根骨骼，<code>node</code>的<code>childNode</code>就是它的子骨骼。因为父骨骼的姿态要影响到子骨骼的姿态（如大腿骨移动，小腿骨骼也要跟着移动），所以要从根节点开始，一层一层递归地计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoneTransform</span><span class="params">(<span class="keyword">float</span> TimeInSeconds, <span class="built_in">vector</span>&lt;Matrix4f&gt;&amp; Transforms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix4f Identity;</span><br><span class="line">Identity.InitIdentity();</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> TicksPerSecond = (<span class="keyword">float</span>)(pScene-&gt;mAnimations[<span class="number">0</span>]-&gt;mTicksPerSecond != <span class="number">0</span> ? pScene-&gt;mAnimations[<span class="number">0</span>]-&gt;mTicksPerSecond : <span class="number">25.0f</span>);</span><br><span class="line"><span class="keyword">float</span> TimeInTicks = TimeInSeconds * TicksPerSecond;</span><br><span class="line"><span class="keyword">float</span> AnimationTime = <span class="built_in">fmod</span>(TimeInTicks, (<span class="keyword">float</span>)pScene-&gt;mAnimations[<span class="number">0</span>]-&gt;mDuration);</span><br><span class="line"></span><br><span class="line">ReadNodeHeirarchy(AnimationTime, pScene-&gt;mRootNode, Identity);</span><br><span class="line"></span><br><span class="line">Transforms.resize(numBones);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; numBones; i++) &#123;</span><br><span class="line">Transforms[i] = allBones[i].FinalTransformation;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前时间找出当前的前一帧和后一帧，再根据时间差线性插值，计算出的平移，旋转和缩放并结合父骨骼的变换作用到当前骨骼上，最后将计算好的当前骨骼的姿态作为父骨骼的变换，递归地处理所有子骨骼：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadNodeHeirarchy</span><span class="params">(<span class="keyword">float</span> AnimationTime, <span class="keyword">const</span> aiNode* pNode, <span class="keyword">const</span> Matrix4f&amp; ParentTransform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">NodeName</span><span class="params">(pNode-&gt;mName.data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aiAnimation* pAnimation = pScene-&gt;mAnimations[<span class="number">0</span>]; <span class="comment">//选择动画</span></span><br><span class="line"></span><br><span class="line"><span class="function">Matrix4f <span class="title">NodeTransformation</span><span class="params">(pNode-&gt;mTransformation)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aiNodeAnim* pNodeAnim = FindNodeAnim(pAnimation, NodeName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNodeAnim) &#123;</span><br><span class="line"><span class="comment">// Interpolate scaling and generate scaling transformation matrix</span></span><br><span class="line">aiVector3D Scaling;</span><br><span class="line">CalcInterpolatedScaling(Scaling, AnimationTime, pNodeAnim);</span><br><span class="line"><span class="comment">// 因为我们项目中的动画没有涉及到大小形变，且有的模型动画自带x100的放大，播放动画的时候会变得非常的大，所以这里将骨骼动画的形变量忽略</span></span><br><span class="line">            <span class="comment">// 忽略scale影响</span></span><br><span class="line">Matrix4f ScalingM;</span><br><span class="line"><span class="comment">//ScalingM.InitIdentity();</span></span><br><span class="line">ScalingM.InitScaleTransform(Scaling.x, Scaling.y, Scaling.z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interpolate rotation and generate rotation transformation matrix</span></span><br><span class="line">aiQuaternion RotationQ;</span><br><span class="line">CalcInterpolatedRotation(RotationQ, AnimationTime, pNodeAnim);</span><br><span class="line">Matrix4f RotationM = Matrix4f(RotationQ.GetMatrix());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interpolate translation and generate translation transformation matrix</span></span><br><span class="line">aiVector3D Translation;</span><br><span class="line">CalcInterpolatedPosition(Translation, AnimationTime, pNodeAnim);</span><br><span class="line">Matrix4f TranslationM;</span><br><span class="line">TranslationM.InitTranslationTransform(Translation.x, Translation.y, Translation.z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Combine the above transformations</span></span><br><span class="line">NodeTransformation = TranslationM * RotationM * ScalingM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix4f GlobalTransformation = ParentTransform * NodeTransformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (boneMap.find(NodeName) != boneMap.end()) &#123;</span><br><span class="line">uint BoneIndex = boneMap[NodeName];</span><br><span class="line">allBones[BoneIndex].FinalTransformation = globalInverseTransform * GlobalTransformation * allBones[BoneIndex].boneOffset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归处理所有子骨骼</span></span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; pNode-&gt;mNumChildren; i++) &#123;</span><br><span class="line">ReadNodeHeirarchy(AnimationTime, pNode-&gt;mChildren[i], GlobalTransformation);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将骨骼姿态作用在顶点上"><a href="#将骨骼姿态作用在顶点上" class="headerlink" title="将骨骼姿态作用在顶点上"></a>将骨骼姿态作用在顶点上</h3><p>最后将计算好的所有的骨骼姿态传入着色器中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BoneTransform(time, Transforms);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBones; i++) &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(uniformName, <span class="string">&quot;gBones[%d]&quot;</span>, i);</span><br><span class="line">    GLuint location = glGetUniformLocation(shader.ID, uniformName);</span><br><span class="line">    glUniformMatrix4fv(location, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)Transforms[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在着色器中，先根据顶点受影响的骨骼ID和权重，计算出当前顶点受骨骼姿态的影响矩阵<code>BoneTransform</code>，顶点在乘以<code>Model，View，Projection</code>矩阵前，先乘以<code>BoneTransform</code>矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line">layout (location = <span class="number">2</span>) in ivec4 BoneIDs;</span><br><span class="line">layout (location = <span class="number">3</span>) in vec4 Weights;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_BONES = <span class="number">100</span>;</span><br><span class="line">uniform mat4 gBones[MAX_BONES];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mat4 BoneTransform = mat4(<span class="number">1.0</span>);</span><br><span class="line">    BoneTransform = gBones[BoneIDs[<span class="number">0</span>]] * Weights[<span class="number">0</span>];</span><br><span class="line">    BoneTransform     += gBones[BoneIDs[<span class="number">1</span>]] * Weights[<span class="number">1</span>];</span><br><span class="line">    BoneTransform     += gBones[BoneIDs[<span class="number">2</span>]] * Weights[<span class="number">2</span>];</span><br><span class="line">    BoneTransform     += gBones[BoneIDs[<span class="number">3</span>]] * Weights[<span class="number">3</span>];</span><br><span class="line">    vs_out.FragPos = vec3(model * BoneTransform * vec4(aPos, <span class="number">1.0</span>));</span><br><span class="line">...</span><br><span class="line">    gl_Position = projection * view * vec4(vs_out.FragPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>扩展后完整的<a href="https://github.com/sysu-cg16/Code/blob/master/CGFinalProject/AnimatedMesh.h">Mesh</a>和<a href="https://github.com/sysu-cg16/Code/blob/master/CGFinalProject/AnimatedModel.h">Model</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/">LeanOpenGL</a></li><li><a href="https://www.youtube.com/watch?v=f3Cr8Yx3GGA">OpenGL Skeletal Animation Tutorial</a></li><li><a href="http://ogldev.atspace.co.uk/www/tutorial38/tutorial38.html">Skeletal Animation With Assimp</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般的模型的加载在&lt;a href=&quot;https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/&quot;&gt;LeanOpenGL&lt;/a&gt;里已经讲解得比较清楚了，本博文是介绍如何在&lt;a href=&quot;https:/</summary>
      
    
    
    
    
    <category term="opengl" scheme="http://yoursite.com/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>小程序云开发总结</title>
    <link href="http://yoursite.com/2019/06/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2019-06-30T14:06:04.000Z</published>
    <updated>2020-12-20T11:10:02.390Z</updated>
    
    <content type="html"><![CDATA[<p>​    <a href="https://swsad.github.io/Dashboard/">系统分析与设计课程项目</a>终于完结撒花了。我在项目中主要负责小程序的后端部分，在项目规划阶段，我们后端组无意间看到了小程序云开发</p><blockquote><ul><li>数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 文档型数据库</li><li>文件存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理</li><li>云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码</li></ul></blockquote><p>看到如此好处，秉持着尝试新鲜技术的精神（懒），我们项目的后端决定采用小程序云开发来实现，从开始感叹它的方便，到中期遇到了种种问题差点放弃改用传统服务器后端，到最后成功做完，这里总结一下经过这几个月的开发，我所理解的小程序云开发的优点和缺点。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>小程序云开发不需要另外租一个服务器</li></ul><p>这个好处还是蛮明显的，小程序开发本身是不需要花费任何钱的，使用云开发服务端的费用也省去，整个开发过程就只有时间成本，完全可以使用云开发小程序做一个人的练手项目。</p><ul><li>用户无需登入</li></ul><p>传统服务器后端确定用户身份是有些复杂的，这就需要根据官方微信小程序的登入流程去走，一系列巴拉巴拉。</p><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg"></p><p>而云函数的参数就能直接确定用户的身份：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js 是入口文件，云函数被调用时会执行该文件导出的 main 方法</span></span><br><span class="line"><span class="comment">// event 包含了调用端（小程序端）调用该函数时传过来的参数，同时还包含了可以通过 getWXContext 方法获取的用户登录态 `openId` 和小程序 `appId` 信息</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line"><span class="built_in">exports</span>.main = <span class="function">(<span class="params">event, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; userInfo, a, b&#125; = event</span><br><span class="line">  <span class="keyword">let</span> &#123; OPENID, APPID &#125; = cloud.getWXContext() <span class="comment">// 这里获取到的 openId 和 appId 是可信的</span></span><br><span class="line">  <span class="keyword">let</span> sum = a + b</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    OPENID,</span><br><span class="line">    APPID,</span><br><span class="line">    sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种种的方便确实使得后端开发的工作量大大减少（因为过于方便，所以后面没事做了也参与了小程序页面的开发Orz)</p><ul><li>方便的日志功能</li></ul><p>每一次云函数的调用都能在云开发控制台查看调用日志，在云函数中使用<code>console.log</code>就能输出自定义的日志，在决定后端代码开发规范的时候，我们就决定云函数要在<a href="%5Bhttps://swsad.github.io/Dashboard/8-%E7%94%9F%E4%BA%A7%E8%A7%84%E8%8C%83%E4%B8%8E%E6%8C%87%E5%8D%97/1.1-%E6%8B%9B%E8%B4%A2%E5%96%B5%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83#3-%E6%97%A5%E5%BF%97%5D(https://swsad.github.io/Dashboard/8-%E7%94%9F%E4%BA%A7%E8%A7%84%E8%8C%83%E4%B8%8E%E6%8C%87%E5%8D%97/1.1-%E6%8B%9B%E8%B4%A2%E5%96%B5%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83#3-%E6%97%A5%E5%BF%97)">输出关键信息</a>，这样的日志输出方面我们在前端返回没有按照预期的时候，能够还原当时云函数的环境，迅速排查错误。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>小程序云开发的服务器不在自己的掌控之中</li></ul><p>云开发后端的性能难以保证，在网上也没有找到具体的说明。且云函数、云数据库、云文件存储的每月调用次数是有限制的。且在开发的几个月中，也遇到过偶尔无法调用云函数的情况，这要看腾讯的实力了。要想确保性能还是要有一个自己的服务器比较安心。前期使用云开发试水，获得不错反响后再换成传统服务器也是不错的方案。</p><ul><li>前端直接使用函数调用的方式，难以遵循<em>RESTful</em>规范</li></ul><p>因为是前端直接函数调用，不需要使用URL，只能通过云函数的名字来表示函数的功能，这是<strong>面向操作</strong>，而不是<em>RESTful</em>所倡导的<strong>面向资源</strong>。</p><p>比如我们获得所有问卷的云函数<code>get_questionnaire</code>，是以动词开头表明是获取，后面才是我们要获取的资源。这样的命名方法导致我们还有<code>fill_in_questionnaire</code>，<code>get_questionnaire_detail</code>的云函数，目前我们只有21个云函数，就已经感觉有一些紊乱了，难以应对大型项目。（PS：项目最后我们想到可以每一个资源有一个Router云函数，再通过参数的调用其他云函数处理，但无奈已经写完了，DDL也到了，没有时间重构）</p><p>而根据<em>RESTful</em>设计出来的API就可以是用<code>GET</code>、<code>POST</code>、<code>DELETE</code>方法访问<code>xxx/questionnaire</code>就能够完成各种针对问卷资源的操作，通过服务端的<code>Router</code>将请求导航到不同的处理函数，使得前端的调用比较简单易理解，后端的处理也更有条理，更易于维护。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>云开发还是比较香的，当前的小程序完全可以先使用云开发，加快开发周期，如果项目成功，再换回传统的服务器来支持更多的用户以及更好的响应速度和稳定性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    &lt;a href=&quot;https://swsad.github.io/Dashboard/&quot;&gt;系统分析与设计课程项目&lt;/a&gt;终于完结撒花了。我在项目中主要负责小程序的后端部分，在项目规划阶段，我们后端组无意间看到了小程序云开发&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CPP智能指针总结</title>
    <link href="http://yoursite.com/2019/04/21/CPP%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/21/CPP%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-21T05:30:07.000Z</published>
    <updated>2020-12-20T11:10:02.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-存在的意义"><a href="#1-存在的意义" class="headerlink" title="1.存在的意义"></a>1.存在的意义</h2><p>在使用一般指针编程的时候会出现的几种错误：</p><ol><li>使用<code>new</code>申请堆空间忘记<code>delete</code></li><li><code>delete</code>之前发生异常，不正常结束，跳过<code>delete</code></li><li>当多线程使用指向同一个堆地址的指针，不知道本线程退出时是否应该<code>delete</code>，以及是使用时否已经<code>delete</code></li></ol><h2 id="2-通用的实现方法"><a href="#2-通用的实现方法" class="headerlink" title="2.通用的实现方法"></a>2.通用的实现方法</h2><p>使用一个类，类的成员变量中有一根指针<code>ptr</code>，类重载指针的操作：解引用<code>*()</code>，调用<code>-&gt;</code>，在析构的时候<code>delete ptr</code>。</p><p>存在的问题：多个智能指针指向同一个堆地址，第一个智能指针析构后，后面的指针析构时就会发生重复<code>delete</code>。</p><p>解决方案：</p><blockquote><ol><li>定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本。（赋值后指向的地址不再相同，失去指针意义）</li><li>建立所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该对象。然后，让赋值操作转让所有权。这就是用于<code>auto_ptr</code>和<code>unique_ptr</code>的策略，但<code>unique_ptr</code>的策略更严格。</li><li>创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数（reference counting）。例如，赋值时，计数将加1，而指针过期时，计数将减1。仅当最后一个指针过期时，才调用delete。这是<code>shared_ptr</code>采用的策略。</li></ol></blockquote><h2 id="3-auto-ptr-amp-unique-ptr"><a href="#3-auto-ptr-amp-unique-ptr" class="headerlink" title="3.auto_ptr &amp; unique_ptr"></a>3.auto_ptr &amp; unique_ptr</h2><p><code>unique_ptr </code>可以传入<code>new[] </code>返回的指针，在定义的时候需要加上<code>[]</code>（只有<code>unique_ptr</code>可以使用<code>new[] </code>）(问题：<code>shared_ptr </code>vs2017中也可以使用<code>new []</code>)。如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;double[]&gt; pad(new double[5]);</span><br><span class="line">pad[<span class="number">3</span>] = <span class="number">3.9</span>; <span class="comment">//像数组一样访问</span></span><br></pre></td></tr></table></figure><p><img src="/.com//pic1.png" alt="pic1"></p><p><code>auto_ptr</code>是<code>c++98</code>标准中的（<code>c++11</code>弃用），<code>unique_ptr</code>是<code>c++11</code>标准中的。 </p><p><code>auto_ptr </code>能够赋值给<code>auto_ptr</code>, 而<code>unique_ptr</code><strong>不</strong>能赋值给<code>unique_ptr</code>（但是<strong>右值</strong><code>unique_ptr</code>能够赋值给<code>unique_ptr</code>）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">demo1</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">demo2</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> *s1 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;some words&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">up1</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="comment">//unique_ptr&lt;string&gt; up2 = up1;  编译不通过</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; up2 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;some words&quot;</span>));</span><br><span class="line">   <span class="comment">// 允许，临时变量为右值</span></span><br><span class="line">   <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; up3 = demo1(<span class="string">&quot;some words&quot;</span>);</span><br><span class="line">   <span class="comment">// 允许，值返回的临时变量为右值</span></span><br><span class="line">   </span><br><span class="line"><span class="built_in">string</span> *s2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;some words&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ap1</span><span class="params">(s2)</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ap2 = ap1;</span><br><span class="line">   <span class="comment">// 允许，但ap1已经失去s2的所有权</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ap3 = <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;some words&quot;</span>));</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ap4 = demo2(<span class="string">&quot;some words&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ap1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 运行时出错</span></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-shared-ptr"><a href="#4-shared-ptr" class="headerlink" title="4. shared_ptr"></a>4. shared_ptr</h2><p><code>shared_ptr</code>中有两个指针：</p><ol><li>构造时传入的指针</li><li>指向控制块的指针</li></ol><p>在<code>shared_ptr</code>拷贝构造或者赋值的时候（如<code>shared_ptr&lt;int&gt;a = b</code>），<code>a</code>的控制块指针指向<code>b</code>的控制块，并将控制块中的引用次数+1（原子操作）。</p><p>由实现可以看出，共享多个<code>shared_ptr</code>，一定要是： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *num = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">6</span>);</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">old_ptr</span><span class="params">(num)</span></span>;</span><br><span class="line"><span class="comment">//成功共享</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; new_ptr = old_ptr;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">new_ptr</span><span class="params">(old_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误共享</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; new_ptr&lt;num&gt;</span><br></pre></td></tr></table></figure><p>line8中的构造方式，<code>new_ptr</code>和<code>old_ptr</code>的控制块并不是同一个，因此会发生多次析构的问题。</p><h3 id="shared-ptr的循环引用问题"><a href="#shared-ptr的循环引用问题" class="headerlink" title="shared_ptr的循环引用问题"></a>shared_ptr的循环引用问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">demo1</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">demo2</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structA</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;structB&gt; Aptr;</span><br><span class="line">~structA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deconstruct  A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;structA&gt; Bptr;</span><br><span class="line">~structB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deconstruct  B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;structA&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> structA)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;structB&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> structB)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ap.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ap-&gt;Aptr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bp-&gt;Bptr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ap-&gt;Aptr = bp;</span><br><span class="line">bp-&gt;Bptr = ap;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ap.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ap-&gt;Aptr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bp-&gt;Bptr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ap.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ap-&gt;Aptr.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>可以看到，在39~40的操作之后，4个智能指针的引用计数器都为2。</li><li>在48行<code>bp</code>析构的时候，因为<code>Aptr</code>还在指向<code>structB</code>，只有<code>bp</code>被析构，<code>bp</code>指向的<code>structB</code>并没有从堆中析构。</li><li>因为<code>structB</code>没有从堆中析构，<code>Bptr</code>仍然指向<code>structA</code>，所以<code>ap</code>析构的时候，<code>ap</code>指向的<code>structA</code>也不会从堆中析构。</li><li>最后情况是堆中既有<code>structA</code>，也有<code>structB</code>，他们的指针的引用计数都为1，内存泄露发生。</li></ol><p>循环引用的避免：</p><ol><li>将其中一个<code>shared_ptr</code>改为<code>weak_ptr</code>（<code>weak_ptr</code>只是一种编译时的循环引用解决方案，如果运行时发生，依然会造成内存泄露）。</li><li>设计时避免循环引用</li></ol><h2 id="5-weak-ptr"><a href="#5-weak-ptr" class="headerlink" title="5. weak_ptr"></a>5. weak_ptr</h2><p>使用较少，暂不探索</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><em><a href="https://blog.csdn.net/xuanyuanlei1020/article/details/81559030">https://blog.csdn.net/xuanyuanlei1020/article/details/81559030</a></em></li><li><em>C++ primer plus 第六版 16.2 智能指针模板类</em></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-存在的意义&quot;&gt;&lt;a href=&quot;#1-存在的意义&quot; class=&quot;headerlink&quot; title=&quot;1.存在的意义&quot;&gt;&lt;/a&gt;1.存在的意义&lt;/h2&gt;&lt;p&gt;在使用一般指针编程的时候会出现的几种错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;new&lt;/co</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="智能指针" scheme="http://yoursite.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>new和delete的重载</title>
    <link href="http://yoursite.com/2019/03/25/new%E5%92%8Cdelete%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/03/25/new%E5%92%8Cdelete%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2019-03-25T08:28:51.000Z</published>
    <updated>2020-12-20T11:10:02.387Z</updated>
    
    <content type="html"><![CDATA[<p>new和delete是一个表达式，执行的过程中会被分解。</p><h2 id="new和delete的分解"><a href="#new和delete的分解" class="headerlink" title="new和delete的分解"></a>new和delete的分解</h2><h3 id="单个对象的new和delete"><a href="#单个对象的new和delete" class="headerlink" title="单个对象的new和delete"></a>单个对象的new和delete</h3><p>表达式<code>String* ps = new String(&quot;hello&quot;);</code>会被分解为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(String)) <span class="comment">//在这个内部调用了malloc</span></span><br><span class="line">ps = <span class="keyword">static_cast</span>&lt;String*&gt;(mem); <span class="comment">//类型的转换</span></span><br><span class="line">ps-&gt;String::String(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//显示地调用构造函数</span></span><br></pre></td></tr></table></figure><p>表达式<code>delete ps;</code>会被分解为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;String::~String(); <span class="comment">//显示调用析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>; <span class="comment">// 释放内存，内部调用free</span></span><br></pre></td></tr></table></figure><h3 id="对象数组的new和delete"><a href="#对象数组的new和delete" class="headerlink" title="对象数组的new和delete"></a>对象数组的new和delete</h3><p>表达式<code>String* ps = new String[5];</code> 会被分解为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void* mem &#x3D; operator new(sizeof(String) * 5 + 4); </span><br><span class="line">&#x2F;&#x2F;new一个数组的时候会有一个int来存储数组的大小</span><br><span class="line">ps &#x3D; static_cast&lt;String*&gt;(mem);</span><br><span class="line">ps-&gt;String();</span><br><span class="line">(ps + 1)-&gt;String();</span><br><span class="line">....&#x2F;&#x2F;共调用五次</span><br></pre></td></tr></table></figure><p>表达式<code>delete[] ps;</code> 会被分解为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;String::~String(); <span class="comment">//显示调用析构函数</span></span><br><span class="line">(ps + <span class="number">1</span>)-&gt;String::~String();</span><br><span class="line">...<span class="comment">//共调用五次</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>; <span class="comment">// 释放内存，内部调用free</span></span><br></pre></td></tr></table></figure><p><strong>由此，如果申请了一个对象数组(<code>new[]</code>)，却使用 delete删除，那么只会调用第一个对象的析构函数，未调用析构函数的对象之前如果申请了堆空间，就会发生内存泄露。</strong></p><h2 id="new和delete的重载"><a href="#new和delete的重载" class="headerlink" title="new和delete的重载"></a>new和delete的重载</h2><p>在对象的public成员函数中重载(可以是static)，可以自定义对象的new的过程，用于内存池：大致就是重载的<code>operator new</code>中不使用<code>malloc</code>而是返回一个已分配好了的内存的指针，<code>operator delete</code>中不使用<code>free</code>，而是将内存返回给内存池，整个过程不向系统索要内存返还内存，没有用户态到系统态的切换，更加快速。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>; <span class="comment">//size_t可有可无</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">size_t</span>); <span class="comment">//size_t可有可无    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后<code>new Foo</code>, <code>delete Foo</code>, <code>new Foo[n]</code>, <code>delete[] p</code>就会使用自定义的操作了。</p><p>如果重载了new和delete却不想使用，可以<code>::new</code>和<code>::delete</code>调用默认的<code>operator new</code>和<code>operator delete</code>。</p><blockquote><p>参考 侯捷 C++程序设计</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;new和delete是一个表达式，执行的过程中会被分解。&lt;/p&gt;
&lt;h2 id=&quot;new和delete的分解&quot;&gt;&lt;a href=&quot;#new和delete的分解&quot; class=&quot;headerlink&quot; title=&quot;new和delete的分解&quot;&gt;&lt;/a&gt;new和delete的</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="new" scheme="http://yoursite.com/tags/new/"/>
    
    <category term="delete" scheme="http://yoursite.com/tags/delete/"/>
    
    <category term="内存池" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统中逻辑时钟与物理时钟的同步</title>
    <link href="http://yoursite.com/2019/03/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F%E4%B8%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E7%9A%84%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/03/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F%E4%B8%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E7%9A%84%E5%90%8C%E6%AD%A5/</id>
    <published>2019-03-12T13:45:21.000Z</published>
    <updated>2020-12-20T12:13:07.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑时钟系统的概念"><a href="#逻辑时钟系统的概念" class="headerlink" title="逻辑时钟系统的概念"></a>逻辑时钟系统的概念</h2><p>在分布式系统中，因为网络的延迟，两台计算机无法拥有一致的时钟（每台计算机之间的时钟看上去只有微小的偏差，但在现代计算机CPU以GHZ为单位计算的频率面前，就是无法容忍的误差了），由于无法拥有一致的时钟，人们使用逻辑时钟来表达，记录分布式系统中的时间。</p><p>一个逻辑时钟系统由一个时间域$T$和映射关系$C$组成。</p><ul><li>T是一个集合，它包含了所有事件发生的逻辑时间，在分布式系统中并不是所有的事件的发生都确定先后关系，所以集合内的元素一般呈现偏序关系。</li><li>映射关系$C​$将每一个事件，映射到这个事件所发生的逻辑时间上：$C: H\longmapsto T​$ ，例如$C(e)​$表示事件$e​$发生的逻辑时间。</li></ul><p>下面是评价逻辑时钟系统的两个特性：</p><ul><li>一致性<ul><li>对于两个事件$e_i$和$e_j$，如果$e_i \rightarrow e_j \Rightarrow C(e_i) &lt; C(e_j)$，则这个逻辑时钟系统是一致的。</li><li>一致性是逻辑时钟系统<strong>必须</strong>满足的特性，否则该系统不具有可用性。</li></ul></li><li>强一致性<ul><li>对于两个事件$e_i$和$e_j$，如果$e_i \rightarrow e_j \Leftrightarrow C(e_i) &lt; C(e_j)$，则这个逻辑时钟系统是强一致的。</li><li>强一致性不是逻辑时钟系统必须满足的，但强一致性能让我们根据两个事件发生的逻辑时钟，推断出它们是否依赖。</li></ul></li></ul><p>逻辑时钟系统中，时间分为<strong>本地时间</strong>和<strong>全局时间</strong>，这里的全局时间不是真正意义上的全局的时间，而是每一个进程视图下的全局时钟，不意味着所有进程上的全局时钟都完全相同。</p><p>时间需要前进，在逻辑时钟系统中，时钟的前进是由事件驱动的：</p><p><strong>R1规则</strong>：对应本地发生的事件</p><ul><li>一个进程发生一个本地事件的时候，进程如何更新自己的本地时间。</li></ul><p><strong>R2规则</strong>：对应消息传递事件</p><ul><li>当进程发送一个消息时，如何将自己视图中的全局时钟附加到消息中，促使目标进程的时钟推进。</li><li>当进程接收到一个消息时，如何使用消息中附加的“发送进程视图的全局时钟”推进自己的全局时钟。</li></ul><p>时间可以由不同的方式表示，时间表示结构有：</p><ol><li>标量时间</li><li>向量时间</li><li>矩阵时间</li><li>…</li></ol><p>下面具体介绍标量时间和向量时间。</p><h2 id="标量时间"><a href="#标量时间" class="headerlink" title="标量时间"></a>标量时间</h2><p>标量时间，顾名思义就是由一个标量表示的时间，通常就是一个整数。我们用$C_i$表示进程$p_i$的逻辑时钟。</p><p>使用标量时钟的时候，本地时钟和全局时钟的值是相等的。</p><p>对于R1规则：进程$p_i$本地时间的更新：$C_i = C_i + 1$</p><p>对于R2规则：</p><ul><li>消息发送：当进程$𝑝_𝑖$发送一个消息时，将逻辑时钟$C_𝑖$附加到消息中（算一种本地事件，本地时钟在消息完成发送之前就已经更新）</li><li>消息接收：当进程$𝑝<em>𝑖$接收到一个消息，且消息携带的逻辑时钟为$C</em>{𝑚𝑠𝑔}$，更新逻辑时钟$C_𝑖=max⁡(𝐶<em>𝑖,  𝐶</em>{𝑚𝑠𝑔})+1$</li></ul><p><img src="/2019/03/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F%E4%B8%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E7%9A%84%E5%90%8C%E6%AD%A5/%E6%A0%87%E9%87%8F%E6%97%B6%E9%97%B4.png" alt="标量时钟更新"></p><h3 id="标量时间的性质"><a href="#标量时间的性质" class="headerlink" title="标量时间的性质"></a>标量时间的性质</h3><p>标量时间是具有一致性的，因为当$e_i \rightarrow e_j$ 成立的时候，有一条从事件$e_i$到事件$e_j$的路径，这个路径中水平的部分(内部事件)，和倾斜的部分(消息传递事件)都会使得逻辑时间增加，就能推出$C(e_i) &lt; C(e_j)$。</p><p>但标量时间不具有强一致性，因为标量集合是全序的，而并不是所有事件发生的先后顺序都能够确定，所以很容易就能找出$C(e_i) &lt; C(e_j)$但是$e_i \nrightarrow e_j$。在上图中，$e_1^3 \nrightarrow e_2^4$，但是$C(e_2^4)  &lt; C(e_1^3)$。</p><p>标量时间可以对数据进行计数，如果事件$e$对应的逻辑时间戳为$h$，则说明到达事件$e$的所有依赖路径中，最长的路径为$h$，$h-1$被称为事件$e$的高度。</p><h2 id="向量时间"><a href="#向量时间" class="headerlink" title="向量时间"></a>向量时间</h2><ol><li>每个进程$p_i$维护一个向量$vt_i[1…n]$，$n$为总进程数，$vt_i$是进程$p_i$的全局时间。</li><li>$vt_i[x]$是进程$p_i$<strong>所掌握</strong>的进程$p_x$的本地时间（不一定是最新的），$vt_i[i]$就是进程$p_i$的本地时间。</li></ol><p>对于R1规则：$vt_i[i] = vt_i[i] + 1$</p><p>对于R2规则：</p><ul><li>消息发送：当进程$𝑝_𝑖$发送一个消息时，将全局时钟$vt_i$顺带发送给接收方（发送之前已经使用R1规则）。</li><li>消息接收：当进程$𝑝_𝑖$接收到一个消息，且携带的全局时钟是$vt$<ol><li>对于$1 \le k \le n : vt_i[k] = max(vt_i[k], vt[k])$, 将全局时钟更新。</li><li>使用R1规则。</li></ol></li></ul><p><img src="/2019/03/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F%E4%B8%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E7%9A%84%E5%90%8C%E6%AD%A5/%E5%90%91%E9%87%8F%E6%97%B6%E9%97%B4.png" alt="1552581103342"></p><p>向量时间的比较规则：</p><p><img src="/2019/03/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F%E4%B8%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E7%9A%84%E5%90%8C%E6%AD%A5/%E5%90%91%E9%87%8F%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99.png" alt="1552581163643"></p><h3 id="向量时间的性质"><a href="#向量时间的性质" class="headerlink" title="向量时间的性质"></a>向量时间的性质</h3><p>向量时间具有一致性，由标量时间的一致性可以很好的得到。</p><p>向量时间具有强一致性，如果有 $vh &lt; vk​$,记$vh​$为进程$p_i​$上事件$h​$的时间戳，$vk​$为进程$p_j​$上事件$k​$的时间戳。由定义可得$vh[i] \le vk[i]​$，而$vh[i]​$进程$p_i​$的本地时间，进程$p_j​$全局时间里的值要大于等于$p_i​$的本地时间，根据更新规则，肯定有一条从$h \rightarrow k​$的路径。</p><p>事件计数：假定时间e的时间戳为$vt[1…n]$</p><ul><li>$vt[j]$表示进程$p_j$上因果关系优于e的事件总数。</li><li>$\sum_{k=1}^n vt[n] - 1$表示在整个计算系统中因果关系先于e的事件总数。</li></ul><h3 id="向量时间压缩"><a href="#向量时间压缩" class="headerlink" title="向量时间压缩"></a>向量时间压缩</h3><p> 当总进程数特别大的话，传递消息附加全局向量时间的成本就会很高（标量时间用4字节的整数来存储的话，1k个进程的全局时间就有4k了）。一个方法是：仅仅发送$vt - vt_{lastsend}$，如果很少改变的话用游长编码就能很好地压缩消息。但是这样需要$O(n^2)$的存储空间。</p><p>下面是改进方法：</p><p>进程$p_i$维护两个向量：</p><ul><li>$LastSend_i[1…n]$，其中$LastSend_i[j]$表示进程$p_i$上次给进程$p_j$发送消息时的本地时间。</li><li>$LastUpdate_i[1…n]$，其中$LastSend_i[k]$表示进程$p_i$上次更新$vt_i[k]$ 时的本地时间。</li></ul><p>当$p_i$需要给进程$p_j$发送消息时，以下向量元素需要发送给进程$p_j$</p><ul><li>如果$LastSend_i [j]&lt;LastUpdate_i [x]$，则第$x$个向量元素需发送到$p_j$。 </li><li>这是因为上面条件的成立说明上次给$p_j$发完消息之后，观测到的进程$p_x$的本地时间更新了，要将这个时间发给$p_j$让它更新。</li></ul><h2 id="NTP时钟同步"><a href="#NTP时钟同步" class="headerlink" title="NTP时钟同步"></a>NTP时钟同步</h2><p>假定两个时钟之间的偏差是$O$，采用如下方法估计$O$。</p><p><img src="/2019/03/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F%E4%B8%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E7%9A%84%E5%90%8C%E6%AD%A5/NTP.png" alt="1552616425880"></p><p>$T_{i-3}$到$T_i-2$之间的传递时间为$t$，$T_{i-1}$到$T_i$之间的传递时间为$t’$，有：</p><ol><li>$T_{i-2} = T_{i-3} + t + O$</li><li>$T_{i} = T_{i-1} + t’ - O$</li></ol><p>由（1） - （2）可得：<br>$$<br>O = \frac{T_{i-2} - T_{i-3} + T_{i - 1} - T_i}{2} + \frac{t’ - t}{2}<br>$$<br>在很短的时间内，我们可以近似认为$t’ - t$等于0，使用加号左边的式子作为$O$的估计，这时候误差的绝对值$|\frac{t’ -t}{2}| \le |\frac{t’ + t}{2}|$，$t + t’$确定了误差的上界。由(1) + (2)可得：<br>$$<br>t + t’ = (T_{i} - T_{i-3}) - (T_{i - 1} - T_2)<br>$$<br>NTP同步方法：</p><p>发送8次交互信息，以$ (T_{i} - T_{i-3}) - (T_{i - 1} - T_2)$最小的参数为基础，计算$O$的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逻辑时钟系统的概念&quot;&gt;&lt;a href=&quot;#逻辑时钟系统的概念&quot; class=&quot;headerlink&quot; title=&quot;逻辑时钟系统的概念&quot;&gt;&lt;/a&gt;逻辑时钟系统的概念&lt;/h2&gt;&lt;p&gt;在分布式系统中，因为网络的延迟，两台计算机无法拥有一致的时钟（每台计算机之间的时钟看</summary>
      
    
    
    
    
    <category term="分布式计算" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>cout格式化输出总结</title>
    <link href="http://yoursite.com/2019/03/10/cout%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/10/cout%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-10T12:20:44.000Z</published>
    <updated>2020-12-20T11:10:02.386Z</updated>
    
    <content type="html"><![CDATA[<p>(带补充完整)</p><h2 id="设置输出最小宽度"><a href="#设置输出最小宽度" class="headerlink" title="设置输出最小宽度"></a>设置输出最小宽度</h2><p><code>setw(n)</code>对应的只是宽度的最小值，如果要输出的长度本身就超过n则不起作用。当宽度小于最小值的时候，<code>left</code>是添加填充字符到右，<code>right</code>是添加填充字符到左，而<code>internal</code>是添加填充字符到内部选定点。 <code>left</code> 与 <code>right</code> 应用到任何输出，而 <code>internal</code> 应用到整数、浮点和货币输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;来源：https:&#x2F;&#x2F;zh.cppreference.com&#x2F;w&#x2F;cpp&#x2F;io&#x2F;manip&#x2F;left</span><br><span class="line">&#x2F;&#x2F;Left fill:</span><br><span class="line">-1.23*******</span><br><span class="line">0x2a********</span><br><span class="line">USD *1.23***</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;Internal fill:</span><br><span class="line">-*******1.23</span><br><span class="line">0x********2a</span><br><span class="line">USD ****1.23</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;Right fill:</span><br><span class="line">*******-1.23</span><br><span class="line">********0x2a</span><br><span class="line">***USD *1.23</span><br></pre></td></tr></table></figure><h2 id="设置浮点数精度"><a href="#设置浮点数精度" class="headerlink" title="设置浮点数精度"></a>设置浮点数精度</h2><p><code>setprecision(n)</code>单独使用，精度n指的是<strong>整个浮点数的位数</strong>，而不是小数的位数，如果浮点数的整数部分位数大于n，那么会采用科学计数法输出，保证n位。</p><p><code>setprecision(n)</code>与<code>fixed</code>(用定点记法生成浮点类型)同时使用，输出浮点数的小数位数就是n了（为什么会这样还不清楚）。<a href="https://baike.baidu.com/item/%E5%AE%9A%E7%82%B9%E6%95%B0/11030127?fr=aladdin">定点数的解释</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">131235.1415</span>, y = <span class="number">3.14159</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//整个浮点数保留4位</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1.312e+005</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//3.142</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed;</span><br><span class="line"><span class="comment">// 小数部分保留4位</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//131235.1415</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3.1416</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;(带补充完整)&lt;/p&gt;
&lt;h2 id=&quot;设置输出最小宽度&quot;&gt;&lt;a href=&quot;#设置输出最小宽度&quot; class=&quot;headerlink&quot; title=&quot;设置输出最小宽度&quot;&gt;&lt;/a&gt;设置输出最小宽度&lt;/h2&gt;&lt;p&gt;&lt;code&gt;setw(n)&lt;/code&gt;对应的只是宽度的最小值</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="cout" scheme="http://yoursite.com/tags/cout/"/>
    
  </entry>
  
  <entry>
    <title>CPP函数指针使用总结</title>
    <link href="http://yoursite.com/2019/03/10/CPP%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/10/CPP%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-10T07:02:04.000Z</published>
    <updated>2020-12-20T11:10:02.380Z</updated>
    
    <content type="html"><![CDATA[<p>原文转自 <a href="https://www.cnblogs.com/lvchaoshun/p/7806248.html">https://www.cnblogs.com/lvchaoshun/p/7806248.html</a> （修改、增加部分内容）</p><h2 id="一-函数指针介绍"><a href="#一-函数指针介绍" class="headerlink" title="一 函数指针介绍"></a>一 函数指针介绍</h2><p>函数指针指向某种特定类型，函数的类型由其参数及返回类型共同决定，与函数名无关。举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;<span class="comment">//函数定义  </span></span><br></pre></td></tr></table></figure><p>该函数类型为int(int,int),要想声明一个指向该类函数的指针，只需用指针替换函数名即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">int</span>,<span class="keyword">int</span>);<span class="comment">//未初始化  </span></span><br></pre></td></tr></table></figure><p>则<code>pf</code>可指向<code>int(int,int)</code>类型的函数。<code>pf</code>前面有<code>*</code>，说明<code>pf</code>是指针，右侧是形参列表，表示<code>pf</code>指向的是函数，左侧为<code>int</code>，说明<code>pf</code>指向的函数返回值为<code>int</code>。则<code>pf</code>可指向<code>int(int,int)</code>类型的函数。而add类型为<code>int(int,int)</code>,则<code>pf</code>可指向add函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = add;<span class="comment">//通过赋值使得函数指针指向某具体函数  </span></span><br></pre></td></tr></table></figure><p>*<em>注意：</em>pf两端的括号必不可少，否则若为如下定义：**</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">pf</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;<span class="comment">//此时pf是一个返回值为int*的函数，而非函数指针  </span></span><br></pre></td></tr></table></figure><h2 id="二-标准C函数指针"><a href="#二-标准C函数指针" class="headerlink" title="二 标准C函数指针"></a>二 标准C函数指针</h2><h3 id="1-函数指针的定义"><a href="#1-函数指针的定义" class="headerlink" title="1 函数指针的定义"></a>1 函数指针的定义</h3><h4 id="1-1-普通函数指针定义"><a href="#1-1-普通函数指针定义" class="headerlink" title="1.1 普通函数指针定义"></a>1.1 普通函数指针定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">int</span>,<span class="keyword">int</span>); </span><br></pre></td></tr></table></figure><h4 id="1-2-使用typedef定义函数指针类型"><a href="#1-2-使用typedef定义函数指针类型" class="headerlink" title="1.2 使用typedef定义函数指针类型"></a>1.2 使用typedef定义函数指针类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//此时，PF为指向某种类型函数的函数指针类型，而不是具体指针，用它可定义具体指针 </span></span><br><span class="line">PF pf;</span><br></pre></td></tr></table></figure><h3 id="2-函数指针的普通使用"><a href="#2-函数指针的普通使用" class="headerlink" title="2 函数指针的普通使用"></a>2 函数指针的普通使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pf = add;  </span><br><span class="line">pf(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//与其指向的函数用法无异  </span></span><br><span class="line">(*pf)(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//此处*pf两端括号必不可少  </span></span><br></pre></td></tr></table></figure><p><strong>注意：add类型必须与pf可指向的函数类型完全匹配</strong></p><h3 id="3-函数指针作为形参"><a href="#3-函数指针作为形参" class="headerlink" title="3 函数指针作为形参"></a>3 函数指针作为形参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个形参为函数类型，会自动转换为指向此类函数的指针  </span></span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="keyword">int</span> nValue,<span class="keyword">int</span> pf(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//等价的声明，显示的将形参定义为指向函数的指针  </span></span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="keyword">int</span> nValue,<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>;  </span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="keyword">int</span> nValue,PF)</span></span>;  </span><br></pre></td></tr></table></figure><p>形参中有函数指针的函数调用，以fuc为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pf = add;<span class="comment">//pf是函数指针  </span></span><br><span class="line">fuc(<span class="number">1</span>,add);<span class="comment">//add自动转换为函数指针  </span></span><br><span class="line">fuc(<span class="number">1</span>,pf);  </span><br></pre></td></tr></table></figure><h3 id="4-返回指向函数的指针"><a href="#4-返回指向函数的指针" class="headerlink" title="4 返回指向函数的指针"></a>4 返回指向函数的指针</h3><h4 id="4-1-使用typedef定义的函数指针类型作为返回参数"><a href="#4-1-使用typedef定义的函数指针类型作为返回参数" class="headerlink" title="4.1 使用typedef定义的函数指针类型作为返回参数"></a>4.1 使用typedef定义的函数指针类型作为返回参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PF <span class="title">fuc2</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//PF为函数指针类型  </span></span><br></pre></td></tr></table></figure><h4 id="4-2-直接定义函数指针作为返回参数"><a href="#4-2-直接定义函数指针作为返回参数" class="headerlink" title="4.2 直接定义函数指针作为返回参数"></a>4.2 直接定义函数指针作为返回参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fuc2(<span class="keyword">int</span>))(<span class="keyword">int</span>,<span class="keyword">int</span>);<span class="comment">//显示定义  </span></span><br></pre></td></tr></table></figure><p><em>说明：按照有内向外的顺序阅读此声明语句。fuc2有形参列表，则fuc2是一个函数，其形参为fuc2(int),fuc2前面有</em>，所以fuc2返回一个指针，指针本身也包含形参列表（int，int），因此指针指向函数，该函数的返回值为int.*</p><p><strong>总结：fuc2是一个函数，形参为(int),返回一个指向int(int,int)的函数指针。</strong></p><h2 id="三-C-函数指针"><a href="#三-C-函数指针" class="headerlink" title="三 C++函数指针"></a>三 C++函数指针</h2><h3 id="1-由于C-完全兼容C，则C中可用的函数指针用法皆可用于C"><a href="#1-由于C-完全兼容C，则C中可用的函数指针用法皆可用于C" class="headerlink" title="1 由于C++完全兼容C，则C中可用的函数指针用法皆可用于C++"></a>1 由于C++完全兼容C，则C中可用的函数指针用法皆可用于C++</h3><h3 id="2-C-其他函数-指针-定义方式及使用"><a href="#2-C-其他函数-指针-定义方式及使用" class="headerlink" title="2 C++其他函数(指针)定义方式及使用"></a>2 C++其他函数(指针)定义方式及使用</h3><h4 id="2-1-typedef与decltype组合定义函数类型"><a href="#2-1-typedef与decltype组合定义函数类型" class="headerlink" title="2.1 typedef与decltype组合定义函数类型"></a>2.1 typedef与decltype组合定义函数类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> add2</span>;  </span><br></pre></td></tr></table></figure><p>decltype返回函数类型,add2是与add相同类型的函数，不同的是add2是类型，而非具体函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">add2* pf;<span class="comment">//pf指向add类型的函数指针，未初始化 </span></span><br></pre></td></tr></table></figure><h4 id="2-2-typedef与decltype组合定义函数指针类型"><a href="#2-2-typedef与decltype组合定义函数指针类型" class="headerlink" title="2.2 typedef与decltype组合定义函数指针类型"></a>2.2 typedef与decltype组合定义函数指针类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span>* PF2</span>;<span class="comment">//PF2与1.1PF意义相同  </span></span><br><span class="line">PF2 pf;<span class="comment">// pf指向int(int,int)类型的函数指针，未初始化  </span></span><br></pre></td></tr></table></figure><h4 id="2-3-使用推断类型关键字auto定义函数类型和函数指针"><a href="#2-3-使用推断类型关键字auto定义函数类型和函数指针" class="headerlink" title="2.3 使用推断类型关键字auto定义函数类型和函数指针"></a>2.3 使用推断类型关键字auto定义函数类型和函数指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pf = add;<span class="comment">//pf可认为是add的别名(个人理解)   </span></span><br><span class="line"><span class="keyword">auto</span> *pf = add;<span class="comment">//pf为指向add的指针  </span></span><br></pre></td></tr></table></figure><h3 id="3-函数指针形参"><a href="#3-函数指针形参" class="headerlink" title="3 函数指针形参"></a>3 函数指针形参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> add2</span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span>* PF2</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuc2</span> <span class="params">(add2 add)</span></span>;<span class="comment">//函数类型形参，调用自动转换为函数指针  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuc2</span> <span class="params">(PF2 add)</span></span>;<span class="comment">//函数指针类型形参，传入对应函数(指针)即可  </span></span><br></pre></td></tr></table></figure><p>说明：不论形参声明的是函数类型：void fuc2 (add2 add);还是函数指针类型void fuc2 (PF2 add);都可作为函数指针形参声明，在参数传入时，若传入函数名，则将其自动转换为函数指针.</p><h3 id="4-返回指向函数的指针-1"><a href="#4-返回指向函数的指针-1" class="headerlink" title="4 返回指向函数的指针"></a>4 返回指向函数的指针</h3><h4 id="4-1-使用auto关键字"><a href="#4-1-使用auto关键字" class="headerlink" title="4.1 使用auto关键字"></a>4.1 使用<code>auto</code>关键字</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto fuc2(int)-&gt; int(*)(int,int) //fuc2返回函数指针为int(*)(int,int)</span><br></pre></td></tr></table></figure><h4 id="4-2-使用decltype关键字"><a href="#4-2-使用decltype关键字" class="headerlink" title="4.2 使用decltype关键字"></a>4.2 使用decltype关键字</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(add)* fuc2(<span class="keyword">int</span>)<span class="comment">//明确知道返回哪个函数，可用decltype关键字推断其函数类型</span></span><br></pre></td></tr></table></figure><h3 id="5-成员函数指针"><a href="#5-成员函数指针" class="headerlink" title="5 成员函数指针"></a>5 成员函数指针</h3><h4 id="5-1普通成员函数指针使用举例"><a href="#5-1普通成员函数指针使用举例" class="headerlink" title="5.1普通成员函数指针使用举例"></a>5.1普通成员函数指针使用举例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>//定义类<span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> (nLeft + nRight);  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuc</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello  world\n&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF1)</span><span class="params">()</span></span>;<span class="comment">//指针名前需加上类名限定  </span></span><br><span class="line"></span><br><span class="line">PF1 pf1 = &amp;A::fuc; <span class="comment">//必须有&amp;  </span></span><br><span class="line">  </span><br><span class="line">A a;<span class="comment">//成员函数地址解引用必须附驻与某个对象地址，所以必须创建一个队形  </span></span><br><span class="line">  </span><br><span class="line">(a.*pf1)();<span class="comment">//使用成员函数指针调用函数 </span></span><br></pre></td></tr></table></figure><h4 id="5-2继承中的函数指针使用举例"><a href="#5-2继承中的函数指针使用举例" class="headerlink" title="5.2继承中的函数指针使用举例"></a>5.2继承中的函数指针使用举例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuc</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello fuc()\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuc2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello A::fuc2()\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuc2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello B::fuc2()\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF1)</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(B::*PF2)</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">PF1 pf1 = &amp;A::fuc;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>         </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    B b; </span><br><span class="line">    (a.*pf1)();  <span class="comment">//调用A::fuc  </span></span><br><span class="line">    (b.*pf1)();   <span class="comment">//调用A::fuc  </span></span><br><span class="line"></span><br><span class="line">    pf1 = &amp;A::fuc2;  </span><br><span class="line">    (a.*pf1)();  <span class="comment">//调用A::fuc2  </span></span><br><span class="line">    (b.*pf1)();  <span class="comment">//调用A::fuc2  </span></span><br><span class="line"></span><br><span class="line">    PF2 pf2 = &amp;A::fuc2;   </span><br><span class="line">    (b.*pf2)(); <span class="comment">//调用A::fuc2</span></span><br><span class="line"></span><br><span class="line">    PF2 pf3 = &amp;B::fuc2;</span><br><span class="line">    (b.*pf3)(); <span class="comment">// 调用B::fuc2    </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="6-重载函数的指针"><a href="#6-重载函数的指针" class="headerlink" title="6 重载函数的指针"></a>6 重载函数的指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuc</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello fuc()\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello A::fuc(int)\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF1)</span><span class="params">()</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF2)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">PF1 pf1 = &amp;A::fuc; <span class="comment">//pf1 指向fuc()</span></span><br><span class="line">PF2 pf2 = &amp;A::fuc; <span class="comment">//pf2 指向fuc(int)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>         </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    (a.*pf1)(); <span class="comment">//Hello fuc()</span></span><br><span class="line">    (a.*pf2)(<span class="number">0</span>);<span class="comment">//Hello A::fuc(int)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文转自 &lt;a href=&quot;https://www.cnblogs.com/lvchaoshun/p/7806248.html&quot;&gt;https://www.cnblogs.com/lvchaoshun/p/7806248.html&lt;/a&gt; （修改、增加部分内容）&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="函数指针" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>cpp-template总结</title>
    <link href="http://yoursite.com/2019/03/06/cpp-template%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/06/cpp-template%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-06T13:29:35.000Z</published>
    <updated>2020-12-20T11:10:02.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T value;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; object1;</span><br><span class="line">A&lt;<span class="keyword">double</span>&gt; object2;</span><br></pre></td></tr></table></figure><p>在实现方面，编译器通过传进来的参数，生成两份class A的代码。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(T arg)</span> </span>&#123;<span class="keyword">const</span> T&amp;a, <span class="keyword">const</span> T&amp; b&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min(<span class="number">2.4</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p>使用函数模板的时候，不需要先声明传递进去的类型，编译器会进行实参推导。</p><h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">some_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">T1 a;</span><br><span class="line">T2 b;</span><br><span class="line">some_struct(T1 arg1, T2 arg2)</span><br><span class="line">    :a(arg1), b(arg2) &#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="keyword">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line">some_struct(<span class="keyword">const</span> some_struct&lt;U1, U2&gt;&amp; p)</span><br><span class="line">: a(p.a), b(p.b) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板里面的成员本身又是一个模板，这里成员模板使得子类能够作为参数去构建父类，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">B b1;</span><br><span class="line">B b2;</span><br><span class="line">some_struct&lt;B, B&gt; temp1(b1, b2);</span><br><span class="line">some_struct&lt;A, A&gt; temp2(temp1); </span><br><span class="line"><span class="comment">// 此时T1，T2是A;U1，U2是B </span></span><br><span class="line"><span class="comment">//如果不写成员模板就无法实现这样的操作</span></span><br></pre></td></tr></table></figure><h2 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h2><p>特化是泛化的反面，是对于模板某些<strong>独特的类型</strong>做特殊的设计。特化需要整个特化，不能只特化原来模板的一部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板偏特化"><a href="#模板偏特化" class="headerlink" title="模板偏特化"></a>模板偏特化</h2><p>分两种情况，一种是参数个数上的偏特化，指的是模板的参数只特化前面一部分（不能有间隔，只特化第1,3,5参数是错误的）。</p><p>例如在标准库中（旧），当vector的第一个模板参数是bool的时候，如果大量的bool值都用原本的一个byte来存储有些不经济，于是对于bool这种情况单独处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;truename Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Alloc&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种是范围上的偏特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T的范围由原来的任意类型，特化到只能是指针，范围缩小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>侯捷 c++程序设计</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类模板&quot;&gt;&lt;a href=&quot;#类模板&quot; class=&quot;headerlink&quot; title=&quot;类模板&quot;&gt;&lt;/a&gt;类模板&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="template" scheme="http://yoursite.com/tags/template/"/>
    
  </entry>
  
  <entry>
    <title>cpp两种特殊的类</title>
    <link href="http://yoursite.com/2019/03/06/cpp%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/06/cpp%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB/</id>
    <published>2019-03-06T13:26:00.000Z</published>
    <updated>2020-12-20T11:10:02.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-point-like-class"><a href="#C-point-like-class" class="headerlink" title="C++ point-like class"></a>C++ point-like class</h2><p>point-like class就是行为像指针的类。point-like class的成员中一定有一个真正的指针，class通过重载 <code>*</code>和<code>-&gt;</code>等指针的操作来实现pointer-like。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>(T* p): ptr(p) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span> *() &#123;</span><br><span class="line"><span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span> -&gt;() &#123;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_method</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line">object temp;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;object&gt; <span class="title">pointer</span><span class="params">(&amp;temp)</span></span>;</span><br><span class="line"></span><br><span class="line">pointer-&gt;some_method(); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-&gt;的重载在C++中比较特殊，pointer-&gt; 在调用了-&gt;之后，返回来的ptr仍然会使用-&gt;作用到some_method;</span></span><br><span class="line"><span class="comment">(*pointer).some_method();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>pointer-like class的例子：STL的迭代器，C++11的智能指针。</p><h2 id="function-like-class"><a href="#function-like-class" class="headerlink" title="function-like class"></a>function-like class</h2><p>function-like class 就是类能像函数一样通过括号传入参数执行，重点就在重载括号。也被称为<strong>仿函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Identify</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x )</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>侯捷 c++程序设计</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-point-like-class&quot;&gt;&lt;a href=&quot;#C-point-like-class&quot; class=&quot;headerlink&quot; title=&quot;C++ point-like class&quot;&gt;&lt;/a&gt;C++ point-like class&lt;/h2&gt;&lt;p&gt;po</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="function_like_class" scheme="http://yoursite.com/tags/function-like-class/"/>
    
    <category term="point_like_class" scheme="http://yoursite.com/tags/point-like-class/"/>
    
  </entry>
  
  <entry>
    <title>转换函数与explicit</title>
    <link href="http://yoursite.com/2019/03/05/%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E4%B8%8Eexplicit/"/>
    <id>http://yoursite.com/2019/03/05/%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E4%B8%8Eexplicit/</id>
    <published>2019-03-04T16:00:37.000Z</published>
    <updated>2020-12-20T11:10:02.391Z</updated>
    
    <content type="html"><![CDATA[<h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><p>C++中存在转换一种特殊的函数–<strong>转换函数</strong>,它没有返回值，作用是将我们的对象转换成其他任意的类型，这个函数常常是由编译器自动调用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>)</span><br><span class="line">    :a(num), b(den) &#123;&#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span> +(<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换函数</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">double</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// main 中</span></span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> temp1 = <span class="number">0.5</span> + f; <span class="comment">// 在这里，编译器会自动调用转换函数将f转为double型</span></span><br></pre></td></tr></table></figure><h4 id="non-explicit构造函数"><a href="#non-explicit构造函数" class="headerlink" title="non-explicit构造函数"></a>non-explicit构造函数</h4><p>non-explicit构造函数是能被编译器隐式调用的构造函数，用于在需要的时候自动将某些数据转变成对象，当non-explicit构造函数只需要填一个参数的时候，就能够起到和转换函数类似的效果。</p><p>但是这样的隐式调用可能会带来意想不到的麻烦，看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承接上面例子</span></span><br><span class="line">    <span class="keyword">double</span> temp2 = f + <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这里编译器会报歧义，因为此处有两种两种解释方法都行得通</span></span><br><span class="line"><span class="comment">1. 和上面的例子一样，直接调用转换函数将f转换为double，相加之后赋值给temp2。</span></span><br><span class="line"><span class="comment">2.  （1）先隐式调用构造函数Fraction(0.5)，将0.5转为Fraction对象</span></span><br><span class="line"><span class="comment">    （2）再调用Fraction重载的+号，计算两个分数之和</span></span><br><span class="line"><span class="comment">    （3）最后再调用转换函数将返回的Fraction对象转为double类型赋值给temp2。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此时就需要<code>explicit</code>关键字了,在Fraction的构造函数上加上这个关键字<code>explicit Fraction(int num, int den = 1)</code>，编译器就不会隐式调用构造函数，就不会产生歧义。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p>侯捷 c++程序设计</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;转换函数&quot;&gt;&lt;a href=&quot;#转换函数&quot; class=&quot;headerlink&quot; title=&quot;转换函数&quot;&gt;&lt;/a&gt;转换函数&lt;/h4&gt;&lt;p&gt;C++中存在转换一种特殊的函数–&lt;strong&gt;转换函数&lt;/strong&gt;,它没有返回值，作用是将我们的对象转换成其他任意的</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="explicit" scheme="http://yoursite.com/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>C++ static关键字再理解</title>
    <link href="http://yoursite.com/2019/03/03/2019%E5%B9%B43%E6%9C%883%E6%97%A5/"/>
    <id>http://yoursite.com/2019/03/03/2019%E5%B9%B43%E6%9C%883%E6%97%A5/</id>
    <published>2019-03-03T08:37:31.000Z</published>
    <updated>2020-12-20T11:10:02.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>在复习单例模式的时候，我看到了网课上给的以下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我不明白为什么反复调用<code>getInstance()</code>并不会创建新的<code>A</code>的对象，返回的一直是第一次调用时创建的<code>a</code>;</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>通过查阅资料得知了:</p><blockquote><p>在函数内声明的static局部变量的生存期也是整个源程序，但其作用域任然和局部变量相同，只是在函数内部可见，退出函数后，尽管变量存在，但是不能使用，下次调用函数的时候，这个局部变量不会再初始化。</p></blockquote><p>用一个例子来解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; func() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output :</span></span><br><span class="line"><span class="comment">0 times 0</span></span><br><span class="line"><span class="comment">1 times 1</span></span><br><span class="line"><span class="comment">2 times 2</span></span><br><span class="line"><span class="comment">3 times 3</span></span><br><span class="line"><span class="comment">4 times 4</span></span><br><span class="line"><span class="comment">5 times 5</span></span><br><span class="line"><span class="comment">6 times 6</span></span><br><span class="line"><span class="comment">7 times 7</span></span><br><span class="line"><span class="comment">8 times 8</span></span><br><span class="line"><span class="comment">9 times 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因为在局部变量<code>count</code>是<code>static</code>的，它的生命期是整个程序，并且只会在第一次调用<code>func</code>的时候初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h2&gt;&lt;p&gt;在复习单例模式的时候，我看到了网课上给的以下示例代码：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;</summary>
      
    
    
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/02/03/hello-world/"/>
    <id>http://yoursite.com/2019/02/03/hello-world/</id>
    <published>2019-02-03T03:02:00.000Z</published>
    <updated>2020-12-20T11:10:02.387Z</updated>
    
    <content type="html"><![CDATA[<p>几天断断续续地搭建了一个github博客，之前写一些类似于博客的东西，但绝大部分都是在有道云笔记上写的，总是因为云笔记其他人无法看到，所以就写得很随意，希望有了这个博客，我能认真记录总结一些东西。9月份收获大厂offer。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几天断断续续地搭建了一个github博客，之前写一些类似于博客的东西，但绝大部分都是在有道云笔记上写的，总是因为云笔记其他人无法看到，所以就写得很随意，希望有了这个博客，我能认真记录总结一些东西。9月份收获大厂offer。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
